
//#include <dune/grid/yaspgrid.hh>
//#include "assemble.hpp"
#include <dune/fufem/assemblers/transferoperatorassembler.hh>

const size_t DIMENSION=1;
const size_t BASE_ORDER=1;
const size_t GRID_LEVEL=1;

typedef Dune::BCRSMatrix<Dune::FieldMatrix<double,1,1> > MatrixType;
typedef Dune::BlockVector<Dune::FieldVector<double,1> > VectorType;

 class fe_manager{
	  
	  size_t n_elem;
	  size_t* n_dof;
	  size_t n_levels;

	  typedef Dune::YaspGrid<1> GridType; 
	  //typedef GridType::LeafGridView GridView;
          typedef GridType::LevelGridView GridView;
	  using BasisFunction = Dune::Functions::PQkNodalBasis<GridView,BASE_ORDER>;
	  

          std::shared_ptr<GridType> grid;
	  
	  //std::shared_ptr<BasisFunction> basis;
	  //std::vector<BasisFunction> basis;
	  //std::shared_ptr<std::vector<std::shared_ptr<BasisFunction>>> basis; 
	  //std::vector<std::shared_ptr<BasisFunction> > fe_basis;

	  std::shared_ptr<TransferOperatorAssembler<Dune::YaspGrid<1>>> transfer;
	  std::shared_ptr<std::vector<MatrixType*>> transferMatrix;
	  MatrixType m1;
		    
	  public:
	  
	   std::vector<std::shared_ptr<BasisFunction> > fe_basis; 
	  //Dune::BCRSMatrix<Dune::FieldMatrix<double,1,1> > M_dune;
          //Dune::BCRSMatrix<Dune::FieldMatrix<double,1,1> > A_dune;  
	    
	  fe_manager(const size_t nelements, size_t nlevels=3)
	  :fe_basis(nlevels), n_levels(nlevels)
	  {
	    //Konstruktor
	    //hier wird das Gitter gebaut und die Basis des FE-Raums gewaehlt

	    n_elem=nelements;
	    n_dof = new size_t [nlevels];

	

	    //if(DIMENSION==2){
	      //Dune::FieldVector<double,DIMENSION> h = {1, 1};
	    //}
	    Dune::FieldVector<double,DIMENSION> h = {1};
	    
	      
	    array<int,DIMENSION> n;
	    std::fill(n.begin(), n.end(), nelements);

	    this->grid  = std::make_shared<GridType>(h,n);
	    //this->basis = std::make_shared<std::vector<BasisFunction*>>(nlevels);
	    //std::vector<std::shared_ptr<BasisFunction>> test  
	    
	    
	    std::cout << "***** Anzahl der finiten Elemente " << nelements << std::endl;
	    std::cout << "***** Ordnung der Basis " << BASE_ORDER << std::endl;
	    
	    //this->basis = new std::vector<BasisFunction>(nlevels);
	    
	    for (int i=0; i< nlevels; i++){
	      grid->globalRefine((bool) i);
	      GridType::LeafGridView gridView = grid->leafGridView();
	      //BasisFunction* b = new BasisFunction(gridView);
	      //std::cout << "***** groesse" << b->size() << std::endl;
	    
	      //basis->push_back(std::make_shared<BasisFunction>(gridView));	
	    
	      //std::cout << "***** groesse" << (&((&basis)[0]))->size() << std::endl;
	      //(*basis)[i]->gridView();
	   
	    
	      //while(basis.size() < nlevels)
	      auto view = grid->levelGridView(i);
              fe_basis[i] = std::make_shared<BasisFunction>(grid->levelGridView(i)); //grid->levelGridView(i));//gridView);
	      n_dof[i]    = fe_basis[i]->size();

	    } 
	    //std::shared_ptr<BasisFunction> ruth = (*basis)[0];
	    //ruth->size();
	    //(*basis)[0]->gridView();
	    
	    std::cout << "***** Ordnung " << fe_basis[0]->size() << std::endl;
	    std::cout << "***** Ordnung " << fe_basis[1]->size() << std::endl;
	    std::cout << "***** Ordnung " << fe_basis[2]->size() << std::endl;

	    if(nlevels>0) this->create_transfer();
	    //this->basis = std::make_shared<BasisFunction>(gridView);

	    //std::cout << "***** Basis erstellt mit " <<  fe_basis[0]->size() << " Elementen " << std::endl;

	    //n_dof=((fe_basis)[0])->size();
	    //std::cout << "***** Ordnung der Basis " << BASE_ORDER << std::endl;
	    //this->encap_factory()->set_size(basis->size());
	    //assembleProblem(((basis)[0]), A_dune, M_dune);
	    //std::cout << "***** Ordnung der Basis " << BASE_ORDER << std::endl;
	    
	    
	  }
	  
	  size_t get_ndofs(size_t i){return n_dof[i];}
	  size_t get_nelem(){return n_elem;}
	  std::shared_ptr<BasisFunction> get_basis(size_t i){return fe_basis[i];}
	  std::shared_ptr<GridType> get_grid(){return grid;}
	  MatrixType get_transfer(size_t l){return *transferMatrix->at(0);}
	  
	  
	  void create_transfer(){
	    transfer = std::make_shared<TransferOperatorAssembler<Dune::YaspGrid<1>>>(*grid);
	    transferMatrix = std::make_shared<std::vector<MatrixType*>>();
	    for (int i=0; i< n_levels; i++){
	      MatrixType m;
	      transferMatrix->push_back(&m);
	    }
	    transfer->assembleMatrixHierarchy<MatrixType>(*transferMatrix);
	  }
	  
	  
	  
};