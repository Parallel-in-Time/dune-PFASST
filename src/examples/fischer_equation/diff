0a1
> 
21c22
< #include "../1d_transfer/fe_manager.hpp"
---
> #include "../2d_transfer/fe_manager_fp.hpp"
24c25
< #include "../1d_transfer/spectral_transfer.hpp"
---
> #include "../2d_transfer/spectral_transfer.hpp"
50c51
<                                            const size_t niter, double newton, double tol) {
---
>                                            const size_t niter, double newton, bool output) {
58,60c59,61
<         typedef Dune::YaspGrid<1,Dune::EquidistantOffsetCoordinates<double, 1> > GridType; 
<         typedef GridType::LevelGridView GridView;
<         using BasisFunction = Dune::Functions::PQkNodalBasis<GridView, BASE_ORDER>;
---
>         //typedef Dune::YaspGrid<1,Dune::EquidistantOffsetCoordinates<double, 1> > GridType; 
>         //typedef GridType::LevelGridView GridView;
>         //using BasisFunction = Dune::Functions::PQkNodalBasis<GridView, BASE_ORDER>;
73,77c74,81
<     
<         Dune::FieldVector<double,DIMENSION> hR = {200};
<         Dune::FieldVector<double,DIMENSION> hL = {-200};
<         array<int,DIMENSION> n;
<         std::fill(n.begin(), n.end(), nelements); 	    
---
>         Dune::FieldVector<typename GridType::ctype,DIMENSION> L;
>         L[0]=1; L[1]=1;
>         typename std::array<int,DIMENSION> s;
>         std::fill(s.begin(), s.end(), nelements);
>         std::bitset<DIMENSION> periodic;//(true, true);
>         periodic[0]=true; //false;//true; 
>         periodic[1]=true; //false;//true;
> 
79,81c83,85
<         grid = std::make_shared<GridType>(hL, hR, n, std::bitset<DIMENSION>{0ULL}, 1, MPI_COMM_SELF);
< #else
<         grid = std::make_shared<GridType>(hL, hR, n);
---
>         grid        = std::make_shared<GridType>(L,s,periodic,0, MPI_COMM_SELF);	
> #else          
>         grid        = std::make_shared<GridType>(L,s,periodic,0);	      
82a87
> 
100d104
<     
108d111
< 
115a119,122
>     	
> Dune::BlockVector<Dune::FieldVector<double, 1>> _new_newton_initial_coarse(fe_basis[1]->size());    
> Dune::BlockVector<Dune::FieldVector<double, 1>> _new_newton_initial_fine(fe_basis[0]->size());    
> 	
120c127
<     for(int ne=0; ne<10; ne++){
---
>     for(int ne=0; ne<5; ne++){
128c135
<         auto fine = std::make_shared<sweeper_t_coarse>(fe_basis[0] , 0, grid);
---
>         auto fine = std::make_shared<sweeper_t_coarse>(fe_basis[0] , 0, grid); //0
136,137c143
<         fine->set_abs_residual_tol(tol);
<         coarse->set_abs_residual_tol(tol);
---
>         
182c188
< 
---
> 	if (time==0){
185c191,194
< 
---
> 	}else{
> 	coarse->initial_state()->data() = _new_newton_initial_coarse; 
> 	fine->initial_state()->data() = _new_newton_initial_fine; 
> 	}
191d199
< 
200c208
< 
---
> 	
289c297
<         std::cout << "******************************************* " <<  std::endl ;
---
>         /*std::cout << "******************************************* " <<  std::endl ;
296c304,317
<         std::cout << "******************************************* " <<  std::endl ;
---
>         std::cout << "******************************************* " <<  std::endl ;*/
> 
> 	if(true){
>         	GridType::LevelGridView gridView = grid->levelGridView(1);
>         	Dune::VTKWriter<GridView> vtkWriter(gridView);
> 
> 
>         	Dune::VTKWriter<GridView> vtkWriter2(gridView);
>         	string name2 = std::to_string(time);
> 
>         	vtkWriter2.addVertexData(fine->get_end_state()->data(), "fe_solution_u");
>         	vtkWriter2.write("fe_2d_nach_solve" + name2);
> 	}
> 
298a320
> 	std::cout << "******************************* Newton " << (_new_newton_state_fine[num_nodes])->norm0() <<  std::endl ;
299a322,348
> 
> 		for(int j=0; j<num_nodes +1 ; j++){
> 		for(int k=0; k< _new_newton_state_coarse[j]->data().size(); k++){
>     			(*_new_newton_state_coarse[j]).data()[k] = coarse->new_newton_state()[j]->data()[k];
> 			//std::cout << "coarse newton solution " << coarse->new_newton_state()[i][j]->data()[k] << std::endl;
>     		}
> 		for(int k=0; k< _new_newton_state_fine[j]->data().size(); k++){
>     			(*_new_newton_state_fine[j]).data()[k] = fine->new_newton_state()[j]->data()[k];
> 			//std::cout << "fine newton solution " << fine->new_newton_state()[i][j]->data()[k] << std::endl;//
> 		}
>     		}
> 		
> 		
> 		for(int j=0; j<num_nodes +1 ; j++){
> 		for(int k=0; k< _new_newton_state_coarse[j]->data().size(); k++){
>     			_new_newton_initial_coarse[k] = coarse->new_newton_state()[j]->data()[k];
> 			//std::cout << "coarse newton solution " << coarse->new_newton_state()[i][j]->data()[k] << std::endl;
>     		}
> 		for(int k=0; k< _new_newton_state_fine[j]->data().size(); k++){
>     			_new_newton_initial_fine[k] = fine->new_newton_state()[j]->data()[k];
> 			//std::cout << "fine newton solution " << fine->new_newton_state()[i][j]->data()[k] << std::endl;//
> 		}
>     		}
> 		
> 		
> 		std::cout << "************************************* STARTING NEW TIMESTEP "<< time << std::endl;
> 	
352,353c401,403
<   const double newton = get_value<double>("newton", 0.1);  
<   const double tol = get_value<double>("abs_res_tol", 1e-12);                    // size of timesteping
---
>   const double newton = get_value<double>("newton", 0.1);                    // size of timesteping
>   bool output = get_value<double>("output", 0);                    // size of timesteping 
>     
369c419
<   run_mlsdc(nelements, BASE_ORDER, DIMENSION, coarse_factor, nnodes, quad_type, t_0, dt, t_end, niter, newton, tol);
---
>   run_mlsdc(nelements, BASE_ORDER, DIMENSION, coarse_factor, nnodes, quad_type, t_0, dt, t_end, niter, newton, output);
