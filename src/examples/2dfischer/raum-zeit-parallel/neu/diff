4,7d3
< #include <vector>
< #include <cmath>
< #include <cstring>
< 
12d7
< #include<dune/common/parallel/mpihelper.hh>
24,27d18
< #include <dune/istl/io.hh>
< #include<dune/istl/matrixmarket.hh>
< #include<dune/istl/matrixredistribute.hh>
< #include <dune/istl/schwarz.hh>
34,35d24
< #include <dune/grid/uggrid.hh>
< #include <dune/grid/io/file/vtk/vtksequencewriter.hh>
46,51c35
< #if USE_DG
< #  include <dune/functions/functionspacebases/lagrangedgbasis.hh>
< #else
< #  include <dune/functions/functionspacebases/pqknodalbasis.hh>
< #endif
< #include <dune/functions/gridfunctions/discreteglobalbasisfunction.hh>
---
> //#include <dune/functions/functionspacebases/pq1nodalbasis.hh>
56a41
>             //dune/fufem/assemblers/istlbackend
60,61c45,71
< #include<dune/istl/paamg/pinfo.hh>
< #include<dune/istl/paamg/graph.hh>
---
> 
> #include <vector>
> #include <cmath>
> #include <cstring>
> 
> #include <dune/common/function.hh>
> #include <dune/common/bitsetvector.hh>
> 
> #include <dune/grid/uggrid.hh>
> #include <dune/grid/yaspgrid.hh>
> #include <dune/grid/io/file/vtk/vtkwriter.hh>
> #include <dune/grid/io/file/vtk/vtksequencewriter.hh>
> 
> #include <dune/istl/matrix.hh>
> #include <dune/istl/bcrsmatrix.hh>
> 
> 
> #include <dune/functions/functionspacebases/interpolate.hh>
> #if USE_DG
> #  include <dune/functions/functionspacebases/lagrangedgbasis.hh>
> #else
> #  include <dune/functions/functionspacebases/pqknodalbasis.hh>
> #endif
> #include <dune/functions/gridfunctions/discreteglobalbasisfunction.hh>
> 
> #include <dune/fufem/assemblers/transferoperatorassembler.hh>
> #include <dune/istl/io.hh>
66a77,83
> // #include <dune/solvers/iterationsteps/blockgsstep.hh>
> #include <dune/solvers/iterationsteps/blockgssteps.hh>
> #include <dune/solvers/norms/energynorm.hh>
> #include <dune/solvers/solvers/loopsolver.hh>
> #include <dune/solvers/transferoperators/compressedmultigridtransfer.hh>
> 
> 
90c107,171
< #include <dune/solvers/iterationsteps/blockgssteps.hh>
---
> 
> #include<dune/istl/bcrsmatrix.hh>
> #include<dune/istl/bvector.hh>
> #include<dune/istl/preconditioners.hh>
> #include<dune/istl/paamg/pinfo.hh>
> #include<dune/istl/solvers.hh>
> #include<dune/istl/matrixmarket.hh>
> #include<dune/istl/matrixredistribute.hh>
> #include<dune/istl/paamg/graph.hh>
> #include<dune/common/parallel/mpihelper.hh>
> #include <dune/istl/schwarz.hh>
> 
> #include <vector>
> #include <cmath>
> #include <cstring>
> 
> #include <dune/common/function.hh>
> #include <dune/common/bitsetvector.hh>
> 
> #include <dune/grid/uggrid.hh>
> #include <dune/grid/yaspgrid.hh>
> #include <dune/grid/io/file/vtk/vtkwriter.hh>
> #include <dune/grid/io/file/vtk/vtksequencewriter.hh>
> 
> #include <dune/istl/matrix.hh>
> #include <dune/istl/bcrsmatrix.hh>
> // #include <dune/istl/preconditioners.hh>
> // #include <dune/istl/solvers.hh>
> 
> #include <dune/functions/functionspacebases/interpolate.hh>
> #if USE_DG
> #  include <dune/functions/functionspacebases/lagrangedgbasis.hh>
> #else
> #  include <dune/functions/functionspacebases/lagrangebasis.hh>
> #endif
> #include <dune/functions/gridfunctions/discreteglobalbasisfunction.hh>
> 
> #include <dune/fufem/assemblers/transferoperatorassembler.hh>
> #include <dune/istl/io.hh>
> #include <dune/parmg/iterationstep/lambdastep.hh>
> #include <dune/parmg/iterationstep/multigrid.hh>
> #include <dune/parmg/iterationstep/multigridstep.hh>
> #include <dune/parmg/norms/normadapter.hh>
> #include <dune/parmg/parallel/communicationp1.hh>
> #include <dune/parmg/parallel/communicationdg.hh>
> #include <dune/parmg/parallel/datahandle.hh>
> #include <dune/parmg/parallel/dofmap.hh>
> #include <dune/parmg/parallel/globaldofindex.hh>
> #include <dune/parmg/parallel/istlcommunication.hh>
> #include <dune/parmg/parallel/matrixalgebra.hh>
> #include <dune/parmg/parallel/vectoralgebra.hh>
> #include <dune/parmg/parallel/parallelenergyfunctional.hh>
> #include <dune/parmg/parallel/parallelenergynorm.hh>
> #include <dune/parmg/parallel/restrictmatrix.hh>
> #include <dune/parmg/solvers/coarsesuperlusolver.hh>
> #include <dune/parmg/solvers/linesearch.hh>
> #include <dune/parmg/solvers/directionsearch.hh>
> #include <dune/parmg/iterationstep/multigridsetup.hh>
> #include <dune/parmg/iterationstep/parallelprojectedgs.hh>
> #if USE_DG
> #  include <dune/parmg/test/dglaplacematrix.hh>
> #else
> #  include <dune/parmg/test/laplacematrix.hh>
> #endif
> // #include <dune/solvers/iterationsteps/blockgsstep.hh>
97d177
< 
121d200
< 
154d232
< //solve frame propagation problem
157a236,238
>         //typedef Dune::YaspGrid<1,Dune::EquidistantOffsetCoordinates<double, 1> > GridType; 
>         //typedef GridType::LevelGridView GridView;
> 	//using BasisFunction = Dune::Functions::PQkNodalBasis<GridView,1>;
160d240
< 	//setup the grid and basis functions //sequential vs parallel (*_global) setup
172a253
>  
184,187c265,268
< 	
< 	int level_number=0;  
< 	grid->globalRefine(level_number);
< 	grid_global->globalRefine(level_number);   
---
> 	  
> 	  
> 	grid->globalRefine(0);
> 	grid_global->globalRefine(0);   
204,205c285
< 	
< 	//setup stiffness and massmatrix use lumping for nonlinear part
---
> 	//std::exit(0);
249c329,330
<         //this must be changed to the system otherwise the norm does not make sence!!!                
---
>                 
>                 
252d332
<         //
256,257c336
<        	
<        	/*for (int i=0; i< A_dune.N(); i++){
---
>        	for (int i=0; i< A_dune.N(); i++){
275,276c354,355
< 	std::cout << "nach der ausgabe " << std::endl;
< 	MPI_Barrier(MPI_COMM_WORLD);*/
---
> 	std::cout << "nach der ausgabe 1" << std::endl;
> 	MPI_Barrier(MPI_COMM_WORLD);
301,303c380,381
< 	//std::cout << "nach der ausgabe" << std::endl;
< 	//MPI_Barrier(MPI_COMM_WORLD);
< 
---
> 	std::cout << "nach der ausgabe" << std::endl;
> 	MPI_Barrier(MPI_COMM_WORLD);
305d382
< 	
312c389
< 	//set initial condition 
---
> 	//const auto dim = 1; //SweeperTrait::DIM;
332c409
<         /*if(rank==0) for(int i=0; i<rhs_global.size(); i++){std::cout << "*****  " << rhs_global[i] << std::endl;}
---
>         if(rank==0) for(int i=0; i<rhs_global.size(); i++){std::cout << "*****  " << rhs_global[i] << std::endl;}
339c416
<     	//std::exit(0);*/
---
>     	//std::exit(0);
342d418
< 	//start newton to solve the resulting nonlinear system
345d420
< 	    //setup jacobi-matrix df and newton_rhs
367,368c442
<             if(rank==0) std::cout << "*************************************************************** rechne Newton-Schritt " << i << std::endl;
<             if(rank==0) std::cout << "globale Systemmatrix " << std::endl;
---
>             
376c450
<             if(rank==0) std::cout << "lokale Systemmatrix " << std::endl;
---
> 
392d465
<             if(rank==0) std::cout << "globale rechte seite " << std::endl;
394d466
<             if(rank==0) std::cout << "lokale rechte seite " << std::endl;
399c471,476
< 	    if (rank==0) std::cout << "*************************************************************** rechne Newton-Schritt " << i << std::endl;
---
> 	    //std::exit(0);
> 	    //if(rank==0) df[0][0]=1;
>             //if(rank==0) df[0][1]=0;
> 
>             //if(rank==1) df[df.N()-1][df.M()-1]=1;
>             //if(rank==1) df[df.N()-1][df.M()-2]=0;
404d480
< //here we use parmg solver to solve the local system (df * u = newton_rhs) for the unknown u
514,516d589
< 
< //here we use dune-istl solver to solve the system (df_globl * u_global = newton_rhs_global)
< 	  
518d590
< 	    //here we treat the boundary conditions
528a601,603
>           
>           
>           
543,544c618,619
< 	    for (int k=0; k<u_global.size(); k++)  if (rank==0) std::cout << "Newton " << i << " Index " << k<< " global u " << u_global[i] << " " << std::endl;	
< 	    for (int k=0; k<u.size(); k++)  if (rank==0) std::cout << "rank 0 Newton " << i << " Index " << k<< " local u " << u[i] << " " << std::endl;
---
> 	    for (int i=0; i<u_global.size(); i++)  if (rank==0) std::cout <<i << " interpolated global u " << u_global[i] << " " << std::endl;	
> 	    for (int i=0; i<u.size(); i++)  if (rank==0) std::cout << "0" << i << " interpolated local u " << u[i] << " " << std::endl;
546c621
< 	    for (int k=0; k<u.size(); k++)  if (rank==1) std::cout << "rank 1 Newton " << i << " Index " << k<< " local u " << u[i] << " " << std::endl;
---
> 	    for (int i=0; i<u.size(); i++)  if (rank==1) std::cout << "1" << i << " interpolated local u " << u[i] << " " << std::endl;
547a623
> 	                std::exit(0);
549,552c625,630
< 	    std::exit(0);
<             //evaluate_f(f_global, u_global, rhs_global, M_dune_global, A_dune_global, *w_global);          
<             //std::cout << i << " residuumsnorm von f(u) " << f_global.infinity_norm() << std::endl;  
<             //if(f_global.infinity_norm()<1e-10){   std::cout << "genauigkeit erreicht " << i << std::endl;      break;} 	  
---
> 
> 	    if(rank==0) for(int i=0; i<u_global.size(); i++){std::cout << "u *****  " << u_global[i] << std::endl;}
> 
>             evaluate_f(f_global, u_global, rhs_global, M_dune_global, A_dune_global, *w_global);          
>             std::cout << i << " residuumsnorm von f(u) " << f_global.infinity_norm() << std::endl;  
>             if(f_global.infinity_norm()<1e-10){   std::cout << "genauigkeit erreicht " << i << std::endl;      break;} 	  
564d641
< 
570d646
< 
572d647
< 
654d728
< 
663d736
< 
681d753
< 
